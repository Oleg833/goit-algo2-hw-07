# goit-algo2-hw-07

# Висновки:

## Завдання 1

## Результати тестування
- **Час виконання без кешування:** 7.04 секунд
- **Час виконання з LRU-кешем:** 7.5 секунд

## Чому кешування не покращило швидкість?
1. **Мала ймовірність повторення однакових запитів**  
   - Оскільки запити `Range` генеруються випадково, імовірність натрапити на точно такий самий інтервал у масиві з 100 000 елементів є низькою.
   - Кеш рідко використовується повторно.

2. **Надмірні витрати на управління кешем**  
   - Використання `OrderedDict` для підтримки LRU-механізму додає накладні витрати на оновлення структури даних.
   - Це зменшує потенційний виграш від кешування.

3. **Часті оновлення анулюють кеш**  
   - Кожен `Update`-запит видаляє всі кешовані значення, які містять оновлений індекс.
   - Оскільки 30% запитів — це `Update`, кеш швидко очищується, що робить його менш ефективним.

## Можливі покращення:
- **Використання ефективніших структур даних**  
  - **Дерево відрізків (Segment Tree)** або **Fenwick Tree (BIT)** можуть значно покращити продуктивність, оскільки дозволяють швидко оновлювати дані та знаходити суму на відрізку.
  
- **Оптимізація розподілу запитів**  
  - Якщо у тестових даних зменшити частку `Update`-запитів, кеш матиме більше шансів на повторне використання.

- **Модифікація кешування**  
  - Зберігати часткові результати для підвідрізків, а не повні `Range`-запити.

## Завдання 2

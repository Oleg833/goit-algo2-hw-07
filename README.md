# goit-algo2-hw-07

# Висновки:

## Завдання 1

## Результати тестування
- **Час виконання без кешування:** 7.10 секунд
- **Час виконання з LRU-кешем:** 8.06 секунд

## Чому кешування не покращило швидкість?
1. **Мала ймовірність повторення однакових запитів**  
   - Оскільки запити `Range` генеруються випадково, імовірність натрапити на точно такий самий інтервал у масиві з 100 000 елементів є низькою.
   - Кеш рідко використовується повторно.

2. **Надмірні витрати на управління кешем**  
   - Використання `OrderedDict` для підтримки LRU-механізму додає накладні витрати на оновлення структури даних.
   - Це зменшує потенційний виграш від кешування.

3. **Часті оновлення анулюють кеш**  
   - Кожен `Update`-запит видаляє всі кешовані значення, які містять оновлений індекс.
   - Оскільки 30% запитів — це `Update`, кеш швидко очищується, що робить його менш ефективним.



## Завдання 2

1. **Метод LRU Cache значно швидший** за Splay Tree для великих значень \( n \), оскільки використовує вбудоване кешування, що дозволяє уникнути зайвих рекурсивних викликів.

2. **Splay Tree вимагає додаткових операцій** для балансування дерева, що збільшує час виконання. Це робить його менш ефективним у порівнянні з LRU Cache.

3. **Для малих значень \( n \)** (до 200) час виконання обох методів є подібним, проте **для великих значень \( n \) LRU Cache є набагато ефективнішим**.

4. **Splay Tree може бути корисним** у випадках, коли кеш має бути керованим структурно, наприклад, у сценаріях з обмеженою пам’яттю або динамічним керуванням кешем.

### Підсумок:
Якщо **потрібно швидке обчислення чисел Фібоначчі**, **LRU Cache є кращим вибором**.
